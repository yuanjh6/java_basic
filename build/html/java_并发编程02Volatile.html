

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>java_并发编程02Volatile &mdash; java基础 v1.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="java_并发编程03Atomic原子类和CAS" href="java_并发编程03Atomic原子类和CAS.html" />
    <link rel="prev" title="java_并发编程01JMM内存模型" href="java_并发编程01JMM内存模型.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> java基础
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="java_读书01guide学习笔记.html">java_读书01guide学习笔记</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书02java核心面试知识整理.html">java_读书02java核心面试知识整理</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书03Java基础高频面试题(2021年最新版).html">java_读书03Java基础高频面试题(2021年最新版)</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书05殷建卫架构笔记之java.html">java_读书05殷建卫架构笔记之java</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础01常见坑.html">java_基础01常见坑</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础02集合.html">java_基础02集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础03双亲委派.html">java_基础03双亲委派</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础04内存结构和gc垃圾回收.html">java_基础04内存结构和gc垃圾回收</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程01JMM内存模型.html">java_并发编程01JMM内存模型</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">java_并发编程02Volatile</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">作用(可见性，举例)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">性能</a></li>
<li class="toctree-l2"><a class="reference internal" href="#volatile">volatile适用的场景</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">状态标志</a></li>
<li class="toctree-l3"><a class="reference internal" href="#one-time-safe-publication">一次性安全发布（one-time safe publication）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#independent-observation">独立观察（independent observation）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">开销较低的读－写锁策略</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#volatile-i">volatile不适合复合操作(i++)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">volatile的原理和实现机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">为什么volatile在并发下也是线程不安全的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">参考</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程03Atomic原子类和CAS.html">java_并发编程03Atomic原子类和CAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程04Synchronized.html">java_并发编程04Synchronized</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程05从锁到ReentrantLock.html">java_并发编程05从锁到ReentrantLock</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程06从ReentrantLock到AQS.html">java_并发编程06从ReentrantLock到AQS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程07锁相关小结.html">java_并发编程07锁相关小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程08CyclicBarrier_CountDownLatch_Semaphore.html">java_并发编程08CyclicBarrier_CountDownLatch_Semaphore</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程09ThreadLocal.html">java_并发编程09ThreadLocal</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程10阻塞队列.html">java_并发编程10阻塞队列</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程11线程池.html">java_并发编程11线程池</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring01读书要点.html">java_spring01读书要点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring02ioc有什么优点.html">java_spring02ioc有什么优点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring03依赖注入与自动装配区别.html">java_spring03依赖注入与自动装配区别</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring04Autowired与Resource差异解析.html">java_spring04Autowired与Resource差异解析</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring05循环依赖.html">java_spring05循环依赖</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_mybatis学习要点.html">java_mybatis学习要点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_微服务01学习笔记.html">java_微服务01学习笔记</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">java基础</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>java_并发编程02Volatile</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/java_并发编程02Volatile.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="java-02volatile">
<h1>java_并发编程02Volatile<a class="headerlink" href="#java-02volatile" title="Permalink to this headline">¶</a></h1>
<p>前置知识：需要先了解 Java内存模型(JMM) 相关知识.</p>
<p>用法:volatile只可以用来修饰变量,不可以修饰方法以及类</p>
<div class="section" id="id1">
<h2>作用(可见性，举例)<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>count++; 这条语句由3条指令组成：</p>
<p>（1）将 count 的值从内存加载到 cpu 的某个寄存器r</p>
<p>（2）将 寄存器r 的值 +1，结果存放在 寄存器s</p>
<p>（3）将 寄存器s 中的值写回内存</p>
<p>所以，如果有多个线程同时在执行 count++;，在某个线程执行完第（3）步之前，<strong>其它线程是看不到它的执行结果</strong>的。</p>
<p>在没有 volatile 的时候，执行完 count++;，执行结果其实是<strong>写到CPU缓存中，没有马上写回到内存中</strong>，后续在某些情况下（比如CPU缓存不够用）再将CPU缓存中的值flush到内存。正因为没有马上写到内存，所以<strong>不能保证其它线程可以及时见到执行的结果</strong>。
在有 volatile 的时候，执行完 count++;，执行结果写到CPU缓存中，<strong>并且同时写回到内存</strong>，因为已经写回内存了，所以可以保证<strong>其它线程马上看到执行的结果</strong>。
但是，<strong>volatile 并没有保证原子性</strong>，在某个线程执行（1）（2）（3）的时候，volatile 并没有锁定 count 的值，也就是并不能阻塞其他线程也执行（1）（2）（3）。可能有两个线程同时执行（1），所以（2）计算出来一样的结果，然后（3）存回的也是同一个值。</p>
</div>
<div class="section" id="id2">
<h2>原理<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Java语言提供了一种<strong>稍弱的同步机制</strong>，即volatile变量，用来确保<strong>将变量的更新操作通知到其他线程</strong>。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此<strong>不会将该变量上的操作与其他内存操作一起重排序</strong>。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p>
<p>在访问volatile变量时<strong>不会执行加锁操作，因此也就不会使执行线程阻塞</strong>，因此volatile变量是一种比sychronized关键字<strong>更轻量级的同步机制</strong>。</p>
<p><img alt="_images/20210404172343728_412130240.png" src="_images/20210404172343728_412130240.png" /></p>
<p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p>
<p>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p>
<p>当一个变量定义为 volatile 之后，将具备两种特性：</p>
<p>1.<strong>保证此变量对所有的线程的可见性</strong>，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。</p>
<p>2.<strong>禁止指令重排序优化</strong>。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个<strong>内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</p>
</div>
<div class="section" id="id3">
<h2>性能<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>volatile 的<strong>读性能消耗与普通变量几乎相同，但是写操作稍慢</strong>，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
</div>
<div class="section" id="volatile">
<h2>volatile适用的场景<a class="headerlink" href="#volatile" title="Permalink to this headline">¶</a></h2>
<p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>1）对变量的写操作不依赖于当前值</p>
<p>2）该变量没有包含在具有其他变量的不变式中</p>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<div class="section" id="id4">
<h3>状态标志<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束.</p>
<p>状态标志并不依赖于程序内任何其他状态，且通常只有一种状态转换</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>volatile boolean shutdownRequested;
...
public void shutdown() { shutdownRequested = true; }

public void doWork() { 
    while (!shutdownRequested) { 
        // todo...
    }
}
</pre></div>
</div>
</div>
<div class="section" id="one-time-safe-publication">
<h3>一次性安全发布（one-time safe publication）<a class="headerlink" href="#one-time-safe-publication" title="Permalink to this headline">¶</a></h3>
<p>在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。（这就是造成著名的双重检查锁定（double-checked-locking）问题的根源）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">TestInstance</span><span class="p">{</span>
	<span class="n">private</span> <span class="n">volatile</span> <span class="n">static</span> <span class="n">TestInstance</span> <span class="n">instance</span><span class="p">;</span>
	
	<span class="n">public</span> <span class="n">static</span> <span class="n">TestInstance</span> <span class="n">getInstance</span><span class="p">(){</span>        <span class="o">//</span><span class="mi">1</span>
		<span class="k">if</span><span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="n">null</span><span class="p">){</span>                        <span class="o">//</span><span class="mi">2</span>
			<span class="n">synchronized</span><span class="p">(</span><span class="n">TestInstance</span><span class="o">.</span><span class="n">class</span><span class="p">){</span>        <span class="o">//</span><span class="mi">3</span>
				<span class="k">if</span><span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="n">null</span><span class="p">){</span>                <span class="o">//</span><span class="mi">4</span>
					<span class="n">instance</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TestInstance</span><span class="p">();</span>   <span class="o">//</span><span class="mi">5</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">instance</span><span class="p">;</span>                             <span class="o">//</span><span class="mi">6</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。instance = new TestInstance();可以分解为3行伪代码</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">.</span> <span class="n">memory</span> <span class="o">=</span> <span class="n">allocate</span><span class="p">()</span> <span class="o">//</span><span class="n">分配内存</span>
<span class="n">b</span><span class="o">.</span> <span class="n">ctorInstanc</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span> <span class="o">//</span><span class="n">初始化对象</span>
<span class="n">c</span><span class="o">.</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">memory</span> <span class="o">//</span><span class="n">设置instance指向刚分配的地址</span>
</pre></div>
</div>
<p>面的代码在编译运行时，可能会出现重排序<strong>从a-b-c排序为a-c-b</strong>。在多线程的情况下会出现以下问题。当线程A在执行第5行代码时，B线程进来执行到第2行代码。假设此时A执行的过程中发生了指令重排序，即先执行了a和c，没有执行b。那么由于A线程执行了c导致instance指向了一段地址，所以B线程判断instance不为null，会直接<strong>跳到第6行并返回一个未初始化的对象</strong>。</p>
</div>
<div class="section" id="independent-observation">
<h3>独立观察（independent observation）<a class="headerlink" href="#independent-observation" title="Permalink to this headline">¶</a></h3>
<p>将 volatile变量用于多个独立观察结果的发布,是”状态标志”的拓展，该值随时会发生变化，同时会被反复使用，前者一般就是用一次 ;只是简单的赋值操作，不会做复合操作.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomLinkedList</span><span class="p">{</span>
    <span class="n">public</span> <span class="n">volatile</span> <span class="n">Node</span> <span class="n">lastNode</span><span class="p">;</span>
    <span class="o">.....</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">add</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Node</span><span class="p">();</span>
        <span class="o">.....</span>
        <span class="n">lastNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span><span class="o">//</span><span class="n">将新节点作为最后一个节点</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>开销较低的读－写锁策略<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>当读远多于写，结合使用内部锁和 volatile 变量来减少同步的开销
利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Counter</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">volatile</span> <span class="nb">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="o">//</span><span class="n">利用volatile保证读取操作的可见性</span><span class="p">,</span> <span class="n">读取时无需加锁</span>
    <span class="n">public</span> <span class="nb">int</span> <span class="n">getValue</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">//</span> <span class="n">使用</span> <span class="n">synchronized</span> <span class="n">加锁</span>
    <span class="n">public</span> <span class="n">synchronized</span> <span class="nb">int</span> <span class="n">increment</span><span class="p">()</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="n">value</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="volatile-i">
<h2>volatile不适合复合操作(i++)<a class="headerlink" href="#volatile-i" title="Permalink to this headline">¶</a></h2>
<p>比如i++此类操作。</p>
<p>解决方法：AtomicInteger,synchronized,lock</p>
</div>
<div class="section" id="id6">
<h2>volatile的原理和实现机制<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>下面这段话摘自《深入理解Java虚拟机》：</p>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，<strong>加入volatile关键字时，会多出一个lock前缀指令</strong> ”</p>
<p>lock前缀指令实际上相当于一个<strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>1）它确保<strong>指令重排序时不会把其后面的指令排到内存屏障之前</strong>的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>2）它会<strong>强制将对缓存的修改操作立即写入主存</strong>；</p>
<p>3）如果是写操作，它会导致其他CPU中对应的<strong>缓存行无效</strong>。</p>
</div>
<div class="section" id="id7">
<h2>为什么volatile在并发下也是线程不安全的<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>java的运算并非原子性的操作，导致volatile在并发下并非是线程安全的。</p>
<p>最简单的例子就是多线程为一个变量连续赋值 每次做到 i++的问题。在进行加一的操作过程中，volatile关键字保证了变量i的值当前是正确的，但是在执行+1操作的指令的过程中，其他线程已经把i的值加大了，此时操作栈顶的值就变成了过期的数据。</p>
</div>
<div class="section" id="id8">
<h2>参考<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>Java中Volatile关键字详解及代码示例:https://www.jb51.net/article/128240.htm</p>
<p>java中关于volatile的理解疑问？:https://www.zhihu.com/question/49656589</p>
<p>Java volatile关键字最全总结：原理剖析与实例讲解(简单易懂):https://blog.csdn.net/u012723673/article/details/80682208</p>
<p>Java面试官最爱问的volatile关键字:https://www.techug.com/post/java-volatile-keyword.html</p>
<p>java并发(4)深入理解volatile:https://www.jianshu.com/p/9e467de97216
Java并发编程：volatile关键字解析:https://www.cnblogs.com/dolphin0520/p/3920373.html</p>
<p>为什么volatile在并发下也是线程不安全的：https://blog.csdn.net/laifu007/article/details/89850299</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="java_并发编程03Atomic原子类和CAS.html" class="btn btn-neutral float-right" title="java_并发编程03Atomic原子类和CAS" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="java_并发编程01JMM内存模型.html" class="btn btn-neutral float-left" title="java_并发编程01JMM内存模型" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, yuanjh

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>