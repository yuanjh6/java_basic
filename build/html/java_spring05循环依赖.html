

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>java_spring05循环依赖 &mdash; java基础 v1.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="java_mybatis学习要点" href="java_mybatis学习要点.html" />
    <link rel="prev" title="java_spring04Autowired与Resource差异解析" href="java_spring04Autowired与Resource差异解析.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> java基础
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="java_读书01guide学习笔记.html">java_读书01guide学习笔记</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书02java核心面试知识整理.html">java_读书02java核心面试知识整理</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书03Java基础高频面试题(2021年最新版).html">java_读书03Java基础高频面试题(2021年最新版)</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书05殷建卫架构笔记之java.html">java_读书05殷建卫架构笔记之java</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础01常见坑.html">java_基础01常见坑</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础02集合.html">java_基础02集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础03双亲委派.html">java_基础03双亲委派</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础04内存结构和gc垃圾回收.html">java_基础04内存结构和gc垃圾回收</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程01JMM内存模型.html">java_并发编程01JMM内存模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程02Volatile.html">java_并发编程02Volatile</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程03Atomic原子类和CAS.html">java_并发编程03Atomic原子类和CAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程04Synchronized.html">java_并发编程04Synchronized</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程05从锁到ReentrantLock.html">java_并发编程05从锁到ReentrantLock</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程06从ReentrantLock到AQS.html">java_并发编程06从ReentrantLock到AQS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程07锁相关小结.html">java_并发编程07锁相关小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程08CyclicBarrier_CountDownLatch_Semaphore.html">java_并发编程08CyclicBarrier_CountDownLatch_Semaphore</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程09ThreadLocal.html">java_并发编程09ThreadLocal</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程10阻塞队列.html">java_并发编程10阻塞队列</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程11线程池.html">java_并发编程11线程池</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring01读书要点.html">java_spring01读书要点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring02ioc有什么优点.html">java_spring02ioc有什么优点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring03依赖注入与自动装配区别.html">java_spring03依赖注入与自动装配区别</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring04Autowired与Resource差异解析.html">java_spring04Autowired与Resource差异解析</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">java_spring05循环依赖</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">三级缓存机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">实例分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">源码解析</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">其他问题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">为什么要使用二级缓存？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">三级缓存存在的意义</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">二级缓存能否解决循环依赖，三级缓存存在的意义</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">是否可以用二级缓存而不用三级缓存？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">面试官：为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">跟踪核心大致流程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">多例和构造器为什么无法解决循环依赖</a></li>
<li class="toctree-l3"><a class="reference internal" href="#springbean">SPRING在创建BEAN的时候，在哪里创建的动态代理？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">允许循环依赖是否合理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gc">gc是否会有问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spring">为什么Spring不能解决构造器的循环依赖？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bean">为什么多实例Bean不能解决循环依赖？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#earlysingletonobjects">earlySingletonObjects二级缓存是鸡肋吗？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#n">循环依赖的N种场景</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">参考</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="java_mybatis学习要点.html">java_mybatis学习要点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_微服务01学习笔记.html">java_微服务01学习笔记</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">java基础</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>java_spring05循环依赖</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/java_spring05循环依赖.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="java-spring05">
<h1>java_spring05循环依赖<a class="headerlink" href="#java-spring05" title="Permalink to this headline">¶</a></h1>
<p>循环依赖：其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图
<img alt="_images/20210401204307817_2036707761.png" src="_images/20210401204307817_2036707761.png" /></p>
<div class="section" id="id1">
<h2>三级缓存机制<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>一个对象一般创建过程有3部分组成：</p>
<p>实例化：简单理解就是new了一个对象</p>
<p>属性注入：为实例化中new出来的对象填充属性</p>
<p>初始化：执行aware接口中的方法，初始化方法，完成AOP代理</p>
<p>Spring中有三个缓存，用于存储单例的Bean实例，这三个缓存是彼此互斥的，不会针对同一个Bean的实例同时存储。</p>
<p>如果调用getBean，则需要从三个缓存中依次获取指定的Bean实例。 读取顺序依次是一级缓存–&gt;二级缓存–&gt;三级缓存</p>
<p><img alt="_images/20210329075703713_1215348952.png" src="_images/20210329075703713_1215348952.png" /></p>
<p>Spring解决循环依赖的核心思想在于<strong>提前曝光</strong>(个人觉得称为<strong>分级曝光</strong>，或<strong>分层曝光</strong>更合理。<strong>提前曝光</strong>侧重<strong>时间视角的先后顺序</strong>，<strong>分级曝光（分层曝光）<strong>侧重</strong>空间视角的次序</strong>，而既然实现的方式为“三级缓存”，所以从<strong>空间视角的命名更为合理</strong>)。</p>
<p>首先，先丢个大概的思路出来</p>
<p>01，对象（或其构造方法，工厂方法，此处认为这仨是一伙的，不特意区别）都是先进入三级缓存</p>
<p>02，稍后，进入二级缓存，同时从三级缓存中清除</p>
<p>03，再稍后，进入一级缓存，同时从二级缓存中清除</p>
<p>整个流程简单来说，就是一个”实例”的<strong>打怪升级</strong>，和<strong>不断丰满</strong>过程</p>
<p>再次，依次理解各级缓存中存放的东西：</p>
<p>第一级缓存:此对象的<strong>完整对象</strong>。类似常规单例模式中常用的key,value=&gt;class,instance的存储模式，如果这个不清楚，随便看个单例模式代码应该就能清楚了。</p>
<p>第二级缓存:此对象被创建，但只有<strong>裸对象，没有属性</strong></p>
<p>第三级缓存:此对象的构造方法出现在spring的代码逻辑中，spring初次认识到有这么个可创建的东西，可以认为存放的是<strong>实例的构造方法，或生成实例的工厂方法等</strong>，他可以生成出第二级缓存需要的<strong>裸对象</strong>。</p>
<p>从这个角度看，<strong>第三级缓存还是存在一定特殊性</strong>的，他存放的<strong>构造方法</strong>，而不是<strong>实例</strong>。</p>
<p>三级缓存更为严谨的定义如下</p>
<p>|         缓存          |                                       说明                                        |
| ——————– | ——————————————————————————– |
| singletonObjects      | 第一级缓存，存放可用的成品Bean。                                                       |
| earlySingletonObjects | 第二级缓存，存放半成品的Bean，半成品的Bean是已创建对象，但是未注入属性和初始化。用以解决循环依赖。 |
| singletonFactories    | 第三级缓存，存的是Bean工厂对象，用来生成半成品的Bean并放入到二级缓存中。用以解决循环依赖。       |</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>singletonObject：一级缓存，该缓存key = beanName, value = bean;这里的bean是已经创建完成的，该bean经历过实例化-&gt;属性填充-&gt;初始化以及各类的后置处理。因此，一旦需要获取bean时，我们第一时间就会寻找一级缓存   
earlySingletonObjects：二级缓存，该缓存key = beanName, value = bean;这里跟一级缓存的区别在于，该缓存所获取到的bean是提前曝光出来的，是还没创建完成的。也就是说获取到的bean只能确保已经进行了实例化，但是属性填充跟初始化肯定还没有做完，因此该bean还没创建完成，仅仅能作为指针提前曝光，被其他bean所引用  
singletonFactories：三级缓存，不是用来存bean的实例，而是用来存函数接口、钩子函数的！该缓存key = beanName, value =beanFactory;在bean实例化完之后，属性填充以及初始化之前，如果允许提前曝光，spring会将实例化后的bean提前曝光，也就是把该bean转换成beanFactory并加入到三级缓存。在需要引用提前曝光对象时再通过singletonFactory.getObject()获取。  
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>实例分析<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>网上有很多现成的实例，不造轮子，直接拿来用。</p>
<p>假设循环注入是A-B-A：A依赖B(A中autowire了B)，B又依赖A（B中又autowire了A）：</p>
<p><img alt="_images/20210329080759968_1518821627.png" src="_images/20210329080759968_1518821627.png" /></p>
<p><img alt="_images/20210415211735658_318706820.png" src="_images/20210415211735658_318706820.png" /></p>
</div>
<div class="section" id="id3">
<h2>源码解析<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>从源码角度分析spring的解决方式</p>
<p>getSingleton(beanName)：</p>
<p><img alt="_images/20210401203826472_1701340748.png" src="_images/20210401203826472_1701340748.png" /></p>
<p>从源码可以得知，doGetBean最初是查询缓存，一二三级缓存全部查询，如果三级缓存存在则将Bean早期引用存放在二级缓存中并移除三级缓存。（升级为二级缓存）</p>
<p>addSingletonFactory：</p>
<p><img alt="_images/20210401203904762_1936335400.png" src="_images/20210401203904762_1936335400.png" /></p>
<p>从源码得知，Bean在实例化完成之后会直接将未装配的Bean工厂存放在三级缓存中，并且移除二级缓存</p>
<p>addSingleton：</p>
<p><img alt="_images/20210401203935651_1945379002.png" src="_images/20210401203935651_1945379002.png" /></p>
<p>一句话，Bean添加到一级缓存，移除二三级缓存。</p>
</div>
<div class="section" id="id4">
<h2>其他问题<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id5">
<h3>为什么要使用二级缓存？<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>二级缓存作用是：暴露早期对象，<strong>为了将 成熟bean 和 纯净bean 分离</strong>。防止多线程中在<strong>Bean还未创建完成时读取到的Bean是不完整的</strong>。</p>
<p>还有一点关于bean的Aop动态代理的问题，我们都知道Bean的aop动态代理创建是在初始化之后，但是循环依赖的Bean如果使用了AOP。 那无法等到解决完循环依赖再创建动态代理， 因为这个时候已经注入属性。 <strong>所以如果循环依赖的Bean使用了aop. 需要提前创建aop</strong>。</p>
</div>
<div class="section" id="id6">
<h3>三级缓存存在的意义<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</p>
</div>
<div class="section" id="id7">
<h3>二级缓存能否解决循环依赖，三级缓存存在的意义<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>我们直接将提前曝光的对象放到二级缓存earlySingletonObjects，Spring循环依赖时直接取就可以解决循环依赖了，为什么还要三级缓存singletonFactory然后再通过getObject()来获取呢？这不是多此一举？</p>
<p>我们回到添加三级缓存，添加SingletonFactory的地方，看看getObject()到底做了什么操作</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">this</span><span class="o">.</span><span class="n">addSingletonFactory</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">getEarlyBeanReference</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span> <span class="n">mbd</span><span class="p">,</span> <span class="n">bean</span><span class="p">);</span>
    <span class="p">});</span>
</pre></div>
</div>
<p>可以看到在返回getObject()时，多做了一步getEarlyBeanReference操作，这步操作是BeanPostProcess的一种，也就是给子类重写的一个后处理器，目的是<strong>用于被提前引用时进行拓展</strong>。即：曝光的时候并不调用该后置处理器，只有曝光，且被提前引用的时候才调用，确保了被提前引用这个时机触发。</p>
</div>
<div class="section" id="id8">
<h3>是否可以用二级缓存而不用三级缓存？<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>答案：不可以，违背Spring在结合AOP跟Bean的生命周期的设计！Spring结合AOP跟Bean的生命周期(看下图)本身就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来完成的，在这个后置处理的postProcessAfterInitialization方法中对初始化后的Bean完成AOP代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的「最后一步完成代理  而不是在实例化后就立马完成代理」。</p>
<p><img alt="_images/20210329081523839_345580743.png" src="_images/20210329081523839_345580743.png" /></p>
<p>使用了三级缓存的情况下，A、B的创建流程</p>
<p><img alt="_images/20210329081601096_1269029399.png" src="_images/20210329081601096_1269029399.png" /></p>
<p>不使用三级缓存，直接在二级缓存中</p>
<p><img alt="_images/20210329081608083_15024116.png" src="_images/20210329081608083_15024116.png" /></p>
<p>结论：上面两个流程的唯一区别在于为A对象创建代理的时机不同，使用三级缓存的情况下为A创建代理的时机是在B中需要注入A的时候，而不使用三级缓存的话在A实例化后就需要马上为A创建代理然后放入到二级缓存中去。三级缓存是无法提速的！</p>
</div>
<div class="section" id="id9">
<h3>面试官：为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p>
</div>
<div class="section" id="id10">
<h3>跟踪核心大致流程<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p><img alt="_images/20210329082036503_618910250.png" src="_images/20210329082036503_618910250.png" /></p>
</div>
<div class="section" id="id11">
<h3>多例和构造器为什么无法解决循环依赖<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>为什么多例Bean不能解决循环依赖？</p>
<p>我们自己手写了解决循环依赖的代码，可以看到，核心是利用一个map，来解决这个问题的，这个map就相当于缓存。
为什么可以这么做，因为我们的bean是单例的，而且是字段注入（setter注入）的，单例意味着只需要创建一次对象，后面就可以从缓存中取出来，字段注入，意味着我们无需调用构造方法进行注入。</p>
<p>如果是原型bean，那么就意味着每次都要去创建对象，无法利用缓存；</p>
<p>如果是构造方法注入，那么就意味着需要调用构造方法注入，也无法利用缓存。</p>
<p>为什么Spring不能解决构造器的循环依赖？</p>
<p>因为构造器是在实例化时调用的，此时bean还没有实例化完成，如果此时出现了循环依赖，一二三级缓存并没有Bean实例的任何相关信息，在实例化之后才放入三级缓存中，因此当getBean的时候缓存并没有命中，这样就抛出了循环依赖的异常了。</p>
</div>
<div class="section" id="springbean">
<h3>SPRING在创建BEAN的时候，在哪里创建的动态代理？<a class="headerlink" href="#springbean" title="Permalink to this headline">¶</a></h3>
<p>①：如果没有循环依赖的话，在bean初始化完成后创建动态代理</p>
<p>②：如果有循环依赖，在bean实例化之后创建！</p>
</div>
<div class="section" id="id12">
<h3>允许循环依赖是否合理<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>个人之前觉的不合理，但后来觉得合理</p>
<p>不合理：设计缺陷，为何有循环依赖出现</p>
<p>合理：的确有实际场景对应，大概率是由于A的部分函数依赖B（可能b只是一部分属性），B的部分函数又依赖A（可能也只是一部分属性），但由于spring的ioc机制，无法精细控制使得我们可以只初始化A的某一部分（也就是分情况初始化，其实可以，但比较麻烦，而且这么做会脱离ioc的初衷）。</p>
</div>
<div class="section" id="gc">
<h3>gc是否会有问题<a class="headerlink" href="#gc" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="spring">
<h3>为什么Spring不能解决构造器的循环依赖？<a class="headerlink" href="#spring" title="Permalink to this headline">¶</a></h3>
<p>从流程图应该不难看出来，在Bean调用构造器实例化之前，一二三级缓存并没有Bean的任何相关信息，在实例化之后才放入三级缓存中，因此当getBean的时候缓存并没有命中，这样就抛出了循环依赖的异常了。</p>
</div>
<div class="section" id="bean">
<h3>为什么多实例Bean不能解决循环依赖？<a class="headerlink" href="#bean" title="Permalink to this headline">¶</a></h3>
<p>多实例Bean是每次创建都会调用doGetBean方法，根本没有使用一二三级缓存，肯定不能解决循环依赖。</p>
</div>
<div class="section" id="earlysingletonobjects">
<h3>earlySingletonObjects二级缓存是鸡肋吗？<a class="headerlink" href="#earlysingletonobjects" title="Permalink to this headline">¶</a></h3>
<p>earlySingletonObjects缓存的目的是，通过三级缓存在获取对象会执行一些列的后置处理器，通过earlySingletonObjects来缓存提升性能。</p>
</div>
<div class="section" id="n">
<h3>循环依赖的N种场景<a class="headerlink" href="#n" title="Permalink to this headline">¶</a></h3>
<p>spring中出现循环依赖主要有以下场景：</p>
<p><img alt="_images/20210327113406822_1556919010.png" src="_images/20210327113406822_1556919010.png" /></p>
<p><img alt="_images/20210329080135388_545578278.png" src="_images/20210329080135388_545578278.png" /></p>
</div>
</div>
<div class="section" id="id13">
<h2>参考<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>Spring解决循环依赖，你真的懂了吗？：https://baijiahao.baidu.com/s?id=1661554759252546253&amp;wfr=spider&amp;for=pc</p>
<p>聊聊Spring循环依赖三级缓存是否可以减少为二级缓存的情况:https://www.jb51.net/article/206470.htm</p>
<p>高频面试题：Spring 如何解决循环依赖？:https://zhuanlan.zhihu.com/p/84267654</p>
<p>框架源码专题：SPRING是如何解决循环依赖的？为什么无法解决多例和构造器的循环依赖:https://www.freesion.com/article/62151334702/</p>
<p>spring解决循环依赖:http://www.zzvips.com/article/108311.html</p>
<p>Spring高频面试题：如何解决循环依赖问题:https://blog.csdn.net/m0_46995061/article/details/109771353</p>
<p>烂大街的Spring循环依赖该如何回答？：https://www.jianshu.com/p/1c250965b1d3</p>
<p>逐行解读Spring- 没人比我更懂循环依赖:https://my.oschina.net/u/4846815/blog/5017044</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="java_mybatis学习要点.html" class="btn btn-neutral float-right" title="java_mybatis学习要点" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="java_spring04Autowired与Resource差异解析.html" class="btn btn-neutral float-left" title="java_spring04Autowired与Resource差异解析" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, yuanjh

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>