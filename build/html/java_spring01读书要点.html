

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>java_spring01读书要点 &mdash; java基础 v1.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="java_spring02ioc有什么优点" href="java_spring02ioc有什么优点.html" />
    <link rel="prev" title="java_并发编程11线程池" href="java_并发编程11线程池.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> java基础
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="java_读书01guide学习笔记.html">java_读书01guide学习笔记</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书02java核心面试知识整理.html">java_读书02java核心面试知识整理</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书03Java基础高频面试题(2021年最新版).html">java_读书03Java基础高频面试题(2021年最新版)</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书05殷建卫架构笔记之java.html">java_读书05殷建卫架构笔记之java</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础01常见坑.html">java_基础01常见坑</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础02集合.html">java_基础02集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础03双亲委派.html">java_基础03双亲委派</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础04内存结构和gc垃圾回收.html">java_基础04内存结构和gc垃圾回收</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程01JMM内存模型.html">java_并发编程01JMM内存模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程02Volatile.html">java_并发编程02Volatile</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程03Atomic原子类和CAS.html">java_并发编程03Atomic原子类和CAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程04Synchronized.html">java_并发编程04Synchronized</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程05从锁到ReentrantLock.html">java_并发编程05从锁到ReentrantLock</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程06从ReentrantLock到AQS.html">java_并发编程06从ReentrantLock到AQS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程07锁相关小结.html">java_并发编程07锁相关小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程08CyclicBarrier_CountDownLatch_Semaphore.html">java_并发编程08CyclicBarrier_CountDownLatch_Semaphore</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程09ThreadLocal.html">java_并发编程09ThreadLocal</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程10阻塞队列.html">java_并发编程10阻塞队列</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程11线程池.html">java_并发编程11线程池</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">java_spring01读书要点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ioc">IoC容器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">IoC是什么鬼</a></li>
<li class="toctree-l3"><a class="reference internal" href="#beanfactory">BeanFactory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applicationcontext">ApplicationContext</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">二者比较</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#di">DI（依赖注入）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#setter">属性注入(无参构造函数+setter方法注入)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">构造注入(通过有参的构造函数注入)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bean">Bean的配置文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">Bean的常用属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">Bean的实例化三方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">Bean的作用域和生命周期</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">Bean的依赖注入</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">设值函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">构造函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id10">Bean的装配</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#xml">xml装配(依赖注入的设值函数，构造函数)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">自动装配</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">注解(常用)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">Bean其他属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aop">AOP（面向切面编程）</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">动态代理(略)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">通知类型(略)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#jdbctemplate">JDBCTemplate</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">事务相关</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#platformtransactionmanager">PlatformTransactionManager</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transactiondefinition">TransactionDefinition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">事务的隔离级别</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transactionstatus">TransactionStatus</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id18">事务管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id19">编程式事务管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">声明式事务管理</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id21">参考</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="java_spring02ioc有什么优点.html">java_spring02ioc有什么优点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring03依赖注入与自动装配区别.html">java_spring03依赖注入与自动装配区别</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring04Autowired与Resource差异解析.html">java_spring04Autowired与Resource差异解析</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring05循环依赖.html">java_spring05循环依赖</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_mybatis学习要点.html">java_mybatis学习要点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_微服务01学习笔记.html">java_微服务01学习笔记</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">java基础</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>java_spring01读书要点</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/java_spring01读书要点.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="java-spring01">
<h1>java_spring01读书要点<a class="headerlink" href="#java-spring01" title="Permalink to this headline">¶</a></h1>
<p>java_spring要点整理</p>
<div class="section" id="ioc">
<h2>IoC容器<a class="headerlink" href="#ioc" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>IoC是什么鬼<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>IoC 是指在程序开发中，实例的创建不再由调用者管理，而是由 Spring 容器创建。Spring 容器会负责控制程序之间的关系，而不是由程序代码直接控制，因此，<strong>控制权由程序代码转移到了 Spring 容器中，控制权发生了反转</strong>，这就是 Spring 的 IoC 思想。</p>
<p>ioc的思想最核心的地方在于，<strong>资源不由使用资源的双方管理，而由不使用资源的第三方管理</strong>，这可以带来很多好处。</p>
<p>第一，<strong>资源集中管理</strong>，实现资源的<strong>可配置和易管理</strong>。</p>
<p>第二，降低了使用资源双方的依赖程度，也就是我们说的<strong>降低耦合度</strong>。</p>
<p>所谓的<strong>依赖注入</strong>，则是甲方开放接口，在它需要的时候，能够讲乙方传递进来(注入)</p>
<p>所谓的<strong>控制反转</strong>，甲乙<strong>双方不相互依赖</strong>，交易活动的进行不依赖于甲乙任何一方，整个活动的进行由第三方负责管理。</p>
<p>Spring 提供了<strong>两种 IoC 容器</strong>，分别为 BeanFactory 和 ApplicationContext。</p>
</div>
<div class="section" id="beanfactory">
<h3>BeanFactory<a class="headerlink" href="#beanfactory" title="Permalink to this headline">¶</a></h3>
<p>BeanFactory 就是一个<strong>管理 Bean 的工厂</strong>，它主要负责初始化各种 Bean，并调用它们的生命周期方法。</p>
<p>BeanFactory 接口有多个实现类，最常见的是 org.springframework.beans.factory.xml.XmlBeanFactory，它是根据 XML 配置文件中的定义装配 Bean 的。</p>
<p>加载配置信息的代码具体如下所示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="n">new</span> <span class="n">XmlBeanFactory</span><span class="p">(</span><span class="n">new</span> <span class="n">FileSystemResource</span><span class="p">(</span><span class="s2">&quot;D://applicationContext.xml&quot;</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="applicationcontext">
<h3>ApplicationContext<a class="headerlink" href="#applicationcontext" title="Permalink to this headline">¶</a></h3>
<p>ApplicationContext 是 BeanFactory 的子接口，也被称为应用上下文。它不仅提供了 BeanFactory 的所有功能，还添加了对 i18n（国际化）、资源访问、事件传播等方面的良好支持。</p>
<p>ApplicationContext 接口有两个常用的实现类：</p>
<p>1）ClassPathXmlApplicationContext</p>
<p>2）FileSystemXmlApplicationContext</p>
<p>它与 ClassPathXmlApplicationContext 的区别是：在读取 Spring 的配置文件时，它可以获取类路径之外的资源，如“F：/workspaces/applicationContext.xml”。</p>
</div>
<div class="section" id="id2">
<h3>二者比较<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>相同点：BeanFactory 和 ApplicationContext 都是通过 XML 配置文件加载 Bean 的。</p>
<p>区别：如果 Bean 的某一个属性没有注入，则使用 BeanFacotry 加载后，在第一次调用 getBean() 方法时会抛出异常，而 ApplicationContext 则在<strong>初始化时自检</strong>，这样有利于检查所依赖的属性是否注入。　　
因此，在实际开发中，<strong>通常都选择使用 ApplicationContext</strong>，而只有在系统资源较少时，才考虑使用 BeanFactory。本教程中使用的就是 ApplicationContext。</p>
</div>
</div>
<div class="section" id="di">
<h2>DI（依赖注入）<a class="headerlink" href="#di" title="Permalink to this headline">¶</a></h2>
<p>实现方式：属性注入和构造注入</p>
<p>依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从<strong>两个角度描述的同一个概念</strong>。</p>
<div class="section" id="setter">
<h3>属性注入(无参构造函数+setter方法注入)<a class="headerlink" href="#setter" title="Permalink to this headline">¶</a></h3>
<p>属性注入<strong>直白易懂</strong>，缺点是对于属性可选的时候，很<strong>多个构造函数会显得类很臃肿</strong>。</p>
</div>
<div class="section" id="id3">
<h3>构造注入(通过有参的构造函数注入)<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>构造注入是一种<strong>高内聚</strong>的体现，特别是针对有些属性需要在对象在创建时候赋值，且后续不允许修改（不提供setter方法）。</p>
</div>
</div>
<div class="section" id="bean">
<h2>Bean的配置文件<a class="headerlink" href="#bean" title="Permalink to this headline">¶</a></h2>
<p>Spring 容器可以被看作一个大工厂，而 Spring 容器中的 Bean 就相当于该工厂的产品。如果希望这个大工厂能够生产和管理 Bean，这时则需要告诉容器需要哪些 Bean，以及需要以何种方式将这些 Bean 装配到一起。</p>
<p>Spring 配置文件支持两种不同的格式，分别是 XML 文件格式和 Properties 文件格式。</p>
</div>
<div class="section" id="id4">
<h2>Bean的常用属性<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>|     属性名称     |                                                          描述                                                          |
| ————– | ——————————————————————————————————————— |
| id              | 是一个 Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成                                                         |
| name            | Spring 容器同样可以通过此属性对容器中的 Bean 进行配置和管理，name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开             |
| class           | 该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，使用类的全限定名                                                           |
| scope           | 用于设定 Bean 实例的作用域，其属性值有 singleton（单例）、prototype（原型）、request、session 和 global Session。其默认值是 singleton |
| constructor-arg | <bean>元素的子元素，可以使用此元素传入构造参数进行实例化。该元素的 index 属性指定构造参数的序号（从 0 开始），type 属性指定构造参数的类型     |
| property        | <bean>元素的子元素，用于调用 Bean 实例中的 Set 方法完成属性赋值，从而完成依赖注入。该元素的 name 属性指定 Bean 实例中的相应属性名          |
| ref             | <property> 和 <constructor-arg> 等元素的子元索，该元素中的 bean 属性用于指定对 Bean 工厂中某个 Bean 实例的引用                      |
| value           | <property> 和 <constractor-arg> 等元素的子元素，用于直接指定一个常量值                                                         |
| list            | 用于封装 List 或数组类型的依赖注入                                                                                          |
| set             | 用于封装 Set 类型属性的依赖注入                                                                                            |
| map             | 用于封装 Map 类型属性的依赖注入                                                                                            |
| entry           | <map> 元素的子元素，用于设置一个键值对。其 key 属性指定字符串类型的键值，ref 或 value子元素指定其值                                   |</p>
</div>
<div class="section" id="id5">
<h2>Bean的实例化三方法<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>构造器实例化：最常用的默认的实例化方式</p>
<p>静态工厂方式实例化：不常用，略</p>
<p>实例工厂方式实例化：不常用，略</p>
<p><strong>实例化和注入有什么区别</strong></p>
<p>实例化：创建对象，</p>
<p>注入：创建对象和对象依赖（或关联）的子对象（属性）</p>
<p>实例必然伴随：权限，作用域（spring统一管理才会面临的问题)，生命周期</p>
</div>
<div class="section" id="id6">
<h2>Bean的作用域和生命周期<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>Spring 容器在初始化一个 Bean 的实例时，同时会指定该实例的作用域。Spring3 为 Bean 定义了五种作用域，具体如下。
1）singleton</p>
<p>单例模式，使用 singleton 定义的 Bean 在 Spring 容器中只有一个实例，这也是 Bean 默认的作用域。</p>
<p>2）prototype</p>
<p>原型模式，每次通过 Spring 容器获取 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例。</p>
<p>3）request</p>
<p>在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Request 内有效。</p>
<p>4）session</p>
<p>在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Session 内有效。</p>
<p>5）global Session</p>
<p>在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。该作用域仅在使用 portlet context 时有效。</p>
<p>对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。<strong>每次客户端请求 prototype 作用域的 Bean 时，Spring 容器都会创建一个新的实例</strong>，并且不会管那些被配置成 prototype 作用域的 Bean 的生命周期。</p>
<p>可以利用 Bean 在其存活期间的指定时刻完成一些相关操作。这种时刻可能有很多，但一般情况下，会在 Bean 被初始化后和被销毁前执行一些相关操作。</p>
<p>根据经验，对<strong>有状态的 bean 应该使用 prototype 作用域</strong>，而对<strong>无状态的bean则应该使用 singleton 作用域</strong>。</p>
<p><img alt="_images/20210314132221520_1907156742.png" src="_images/20210314132221520_1907156742.png" /></p>
</div>
<div class="section" id="id7">
<h2>Bean的依赖注入<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id8">
<h3>设值函数<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>在 Spring 实例化 Bean 的过程中，首先会调用默认的构造方法实例化 Bean 对象，然后通过 Java 的反射机制调用 setXxx() 方法进行属性的注入。因此，设值注入要求一个 Bean 的对应类必须满足以下两点要求。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>必须提供一个默认的无参构造方法。   
必须为需要注入的属性提供对应的 setter 方法。  
</pre></div>
</div>
<p>使用设值注入时，在 Spring 配置文件中，需要使用 <bean> 元素的子元素 <property> 元素为每个属性注入值。而使用构造注入时，在配置文件中，主要使用 <constructor-arg> 标签定义构造方法的参数，可以使用其 value 属性（或子元素）设置该参数的值。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;!-- Definition for textEditor bean --&gt;
&lt;bean id=&quot;textEditor&quot; class=&quot;com.tutorialspoint.TextEditor&quot;&gt;
   &lt;property name=&quot;spellChecker&quot; ref=&quot;spellChecker&quot; /&gt;
   &lt;property name=&quot;name&quot; value=&quot;Generic Text Editor&quot; /&gt;
&lt;/bean&gt;

&lt;!-- Definition for javaCollection --&gt;
&lt;bean id=&quot;javaCollection&quot; class=&quot;com.tutorialspoint.JavaCollection&quot;&gt;

  &lt;!-- results in a setAddressList(java.util.List) call --&gt;
  &lt;property name=&quot;addressList&quot;&gt;
     &lt;list&gt;
        &lt;value&gt;INDIA&lt;/value&gt;
        &lt;value&gt;Pakistan&lt;/value&gt;
        &lt;value&gt;USA&lt;/value&gt;
        &lt;value&gt;USA&lt;/value&gt;
     &lt;/list&gt;
  &lt;/property&gt;

  &lt;!-- results in a setAddressSet(java.util.Set) call --&gt;
  &lt;property name=&quot;addressSet&quot;&gt;
     &lt;set&gt;
        &lt;value&gt;INDIA&lt;/value&gt;
        &lt;value&gt;Pakistan&lt;/value&gt;
        &lt;value&gt;USA&lt;/value&gt;
        &lt;value&gt;USA&lt;/value&gt;
    &lt;/set&gt;
  &lt;/property&gt;

  &lt;!-- results in a setAddressMap(java.util.Map) call --&gt;
  &lt;property name=&quot;addressMap&quot;&gt;
     &lt;map&gt;
        &lt;entry key=&quot;1&quot; value=&quot;INDIA&quot;/&gt;
        &lt;entry key=&quot;2&quot; value=&quot;Pakistan&quot;/&gt;
        &lt;entry key=&quot;3&quot; value=&quot;USA&quot;/&gt;
        &lt;entry key=&quot;4&quot; value=&quot;USA&quot;/&gt;
     &lt;/map&gt;
  &lt;/property&gt;

  &lt;!-- results in a setAddressProp(java.util.Properties) call --&gt;
  &lt;property name=&quot;addressProp&quot;&gt;
     &lt;props&gt;
        &lt;prop key=&quot;one&quot;&gt;INDIA&lt;/prop&gt;
        &lt;prop key=&quot;two&quot;&gt;Pakistan&lt;/prop&gt;
        &lt;prop key=&quot;three&quot;&gt;USA&lt;/prop&gt;
        &lt;prop key=&quot;four&quot;&gt;USA&lt;/prop&gt;
     &lt;/props&gt;
  &lt;/property&gt;

&lt;/bean&gt;
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h3>构造函数<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>举例</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">TextEditor</span> <span class="p">{</span>
   <span class="n">private</span> <span class="n">SpellChecker</span> <span class="n">spellChecker</span><span class="p">;</span>
   <span class="n">public</span> <span class="n">TextEditor</span><span class="p">(</span><span class="n">SpellChecker</span> <span class="n">spellChecker</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Inside TextEditor constructor.&quot;</span> <span class="p">);</span>
      <span class="n">this</span><span class="o">.</span><span class="n">spellChecker</span> <span class="o">=</span> <span class="n">spellChecker</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="n">public</span> <span class="n">void</span> <span class="n">spellCheck</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">spellChecker</span><span class="o">.</span><span class="n">checkSpelling</span><span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对应xml配置文件</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   &lt;!-- Definition for textEditor bean --&gt;
   &lt;bean id=&quot;textEditor&quot; class=&quot;com.tutorialspoint.TextEditor&quot;&gt;
      &lt;constructor-arg ref=&quot;spellChecker&quot;/&gt;
   &lt;/bean&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="id10">
<h2>Bean的装配<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<div class="section" id="xml">
<h3>xml装配(依赖注入的设值函数，构造函数)<a class="headerlink" href="#xml" title="Permalink to this headline">¶</a></h3>
<p>举例:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> &lt;!-- 使用设值注入方式装配Person实例 --&gt;
    &lt;bean id=&quot;person1&quot; class=&quot;com.mengma.assembly.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot; /&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot; /&gt;
    &lt;/bean&gt;
    &lt;!-- 使用构造方法装配Person实例 --&gt;
    &lt;bean id=&quot;person2&quot; class=&quot;com.mengma.assembly.Person&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;lisi&quot; /&gt;
        &lt;constructor-arg index=&quot;1&quot; value=&quot;21&quot; /&gt;
    &lt;/bean&gt;
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>自动装配<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>自动装配就是指 Spring 容器可以自动装配（autowire）相互协作的 Bean 之间的关联关系，将一个 Bean 注入其他 Bean 的 Property 中。</p>
<p>要使用自动装配，就需要配置 <bean> 元素的 autowire 属性。autowire 属性有五个值</p>
<p>| 名称 | 说明 |
| — | — |
| byName | 根据 Property 的 name 自动装配，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。 |
| byType | 根据 Property 的数据类型（Type）自动装配，如果一个 Bean 的数据类型兼容另一个 Bean 中 Property 的数据类型，则自动装配。 |
| constructor | 根据构造方法的参数的数据类型，进行 byType 模式的自动装配。 |
| autodetect | 如果发现默认的构造方法，则用 constructor 模式，否则用 byType 模式。 |
| no | 默认情况下，不使用自动装配，Bean 依赖必须通过 ref 元素定义。 |</p>
</div>
<div class="section" id="id12">
<h3>注解(常用)<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>@Component：用于描述Spring中的Bean，它是一个泛化的概念，仅仅表示一个组件。
@Repository：用于将数据访问层（DAO）的类标识为Spring中的Bean。
@Service：用于将业务层中的类标识Spring中的Bean。
@Autowired：用于对Bean的属性变量、属性的setter方法及构造方法进行标注，配合对应的注解处理器完成Bean的自动配置工作。
@Resource：其作用与Autowired作用一样。@Resource中有两个重要属性：name和type。Spring将name属性解析为Bean实例名称，type属性解析为Bean实例类型。
@Qualifier：与@Autowired注解配合使用，会将默认的按Bean类型装配修改为按Bean的实例名称装配，Bean的实例名称由@Qualifier注解的参数指定。
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>Bean其他属性<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p><strong>后置处理器</strong></p>
<p>Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理</p>
<p><strong>Bean 定义继承</strong></p>
<p>子 bean 的定义继承父定义的配置数据。子定义可以根据需要重写一些值，或者添加其他值。</p>
<p><strong>Spring Bean 定义的继承与 Java 类的继承无关</strong>，但是继承的概念是一样的。你可以定义一个父 bean 的定义作为模板和其他子 bean 就可以从父 bean 中继承所需的配置。</p>
<p>当你使用基于 XML 的配置元数据时，通过使用父属性，指定父 bean 作为该属性的值来表明子 bean 的定义。</p>
<p><strong>Bean 定义模板</strong>
你可以创建一个 Bean 定义模板，不需要花太多功夫它就可以被其他子 bean 定义使用。在定义一个 Bean 定义模板时，你不应该指定类的属性，而应该指定带 true 值的抽象属性。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">bean</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;beanTeamplate&quot;</span> <span class="n">abstract</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;message1&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;Hello World!&quot;</span><span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;message2&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;Hello Second World!&quot;</span><span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;message3&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;Namaste India!&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">bean</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;helloIndia&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;com.tutorialspoint.HelloIndia&quot;</span> <span class="n">parent</span><span class="o">=</span><span class="s2">&quot;beanTeamplate&quot;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;message1&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;Hello India!&quot;</span><span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="nb">property</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;message3&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s2">&quot;Namaste India!&quot;</span><span class="o">/&gt;</span>
<span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="aop">
<h2>AOP（面向切面编程）<a class="headerlink" href="#aop" title="Permalink to this headline">¶</a></h2>
<p>AOP 的全称是“Aspect Oriented Programming”，即面向切面编程，它将<strong>业务逻辑的各个部分进行隔离</strong>，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高了开发效率。</p>
<p>面向切面编程（AOP）和面向对象编程（OOP）类似，也是<strong>一种编程模式</strong>。Spring AOP 是基于 AOP 编程模式的一个框架，它的使用有效<strong>减少了系统间的重复代码，达到了模块间的松耦合</strong>目的。</p>
<p>AOP 采取<strong>横向抽取机制</strong>，取代了传统纵向继承体系的重复性代码，其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。</p>
<p>目前最流行的 AOP 框架有两个，分别为 Spring AOP 和 AspectJ。</p>
</div>
<div class="section" id="id14">
<h2>动态代理(略)<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id15">
<h2>通知类型(略)<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="jdbctemplate">
<h2>JDBCTemplate<a class="headerlink" href="#jdbctemplate" title="Permalink to this headline">¶</a></h2>
<p>Spring 框架针对数据库开发中的应用提供了 JDBCTemplate 类，该类是 Spring 对 JDBC 支持的核心，它提供了所有对数据库操作功能的支持。</p>
<p>在定义 jdbcTemplate 时，需要将 dataSource 注入 jdbcTemplate 中。而在其他的类中要使用 jdbcTemplate，也需要将 jdbcTemplate 注入使用类中（通常注入 dao 类中）。</p>
</div>
<div class="section" id="id16">
<h2>事务相关<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>Spring 的事务管理是<strong>基于 AOP 实现的</strong>，而 AOP 是以方法为单位的。Spring 的<strong>事务属性分别为传播行为、隔离级别、只读和超时属性</strong>，这些属性提供了事务应用的方法和描述策略。</p>
<div class="section" id="platformtransactionmanager">
<h3>PlatformTransactionManager<a class="headerlink" href="#platformtransactionmanager" title="Permalink to this headline">¶</a></h3>
<p>PlatformTransactionManager 接口是 Spring 提供的平台事务管理器，用于管理事务。该接口中提供了三个事务操作方法，具体如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>TransactionStatus getTransaction（TransactionDefinition definition）：用于获取事务状态信息。
void commit（TransactionStatus status）：用于提交事务。
void rollback（TransactionStatus status）：用于回滚事务。
</pre></div>
</div>
</div>
<div class="section" id="transactiondefinition">
<h3>TransactionDefinition<a class="headerlink" href="#transactiondefinition" title="Permalink to this headline">¶</a></h3>
<p>TransactionDefinition 接口是事务定义（描述）的对象，它提供了事务相关信息获取的方法，其中包括五个操作，具体如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>String getName()：获取事务对象名称。
int getIsolationLevel()：获取事务的隔离级别。
int getPropagationBehavior()：获取事务的传播行为。
int getTimeout()：获取事务的超时时间。
boolean isReadOnly()：获取事务是否只读。
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h3>事务的隔离级别<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>| 不同传播机制 | 事务名称 | 描述 | 事务管理器要求 | 是否支持事务 | 是否开启新事务 | 回滚规则 |
| ———- | —— | —- | ———– | ———- | ———– | —— |
| REQUIRED      | 要求    | 存在加入，不存在创建新      | 无                          | ✅         | 不一定                          |  存在一个事务：1.外部有事务加入，异常回滚；2.外部没事务创建新事务，异常回滚                                                            |
| SUPPORTS      | 支持    | 存在加入，不存在非事务      | 无                          | ✅         | ❎                             | 最多只存在一个事务： 1.外部有事务加入，异常回滚；2.外部没事务，内部非事务，异常不回滚                                                    |
| MANDATORY     | 强制    | 存在加入，不存在抛异常      | 无                          | ✅         | ❎                             | 最多只存在一个事务： 1.外部存在事务加入，异常回滚；2.外部不存在事务，异常无法回滚                                                       |
| REQUIRES_NEW  | 要求新   | 存在挂起创建新，不存在创建新 | 无                          | ✅         | ✅                             | 可能存在1-2个事务：1.外部存在事务挂起，创建新，异常回滚自己的事务 2.外部不存在事务，创建新， 异常只回滚新事务                                |
| NOT_SUPPORTED | 不支持   | 存在挂起，不存在非事务      | 无                          |  ❎         | ❎                             | 最多只存在一个事务：1. 外部有事务挂起，外部异常回滚；内部非事务，异常不回滚2.外部无事务，内部非事务，异常不回滚                              |
|  NEVER        | 坚决不   | 存在抛异常               | 无                          | ❎         |  ❎                            |  最多只存在一个事务：1.外部有事务，外部异常回滚；内部非事务不回滚 2.外部非事务，内部非事务，异常不回滚                                      |
| NESTED        | 嵌套    | 存在嵌套，不存在创建新      | DataSourceTransactionManager | ✅         |  ❎（同一个物理事务，保存点实现嵌套） | 存在一个事务：1. 外部有事务，嵌套事务创建保存点，外部异常回滚全部事务；内部嵌套事务异常回滚到保存点；2.外部不存在事务，内部创建新事务，内部异常回滚 |</p>
</div>
<div class="section" id="transactionstatus">
<h3>TransactionStatus<a class="headerlink" href="#transactionstatus" title="Permalink to this headline">¶</a></h3>
<p>TransactionStatus 接口是事务的状态，它描述了某一时间点上事务的状态信息。</p>
<p>| 名称 | 说明 |
| — | — |
| void flush() | 刷新事务 |
| boolean hasSavepoint() | 获取是否存在保存点 |
| boolean isCompleted() | 获取事务是否完成 |
| boolean isNewTransaction() | 获取是否是新事务 |
| boolean isRollbackOnly() | 获取是否回滚 |
| void setRollbackOnly() | 设置事务回滚 |</p>
</div>
</div>
<div class="section" id="id18">
<h2>事务管理<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id19">
<h3>编程式事务管理<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>直接调用PlatformTransactionManager的commit，rollback等函数实现的事务管理.</p>
<p>优点是灵活性较好，缺点是可读性，可维护性较差。实际<strong>开发中基本不会使用</strong>到。</p>
</div>
<div class="section" id="id20">
<h3>声明式事务管理<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>基于 AOP 技术实现的，按照配置方式可分为基于xml的和Annotation的</p>
<p>基于xml的相对更为灵活，可独立配置是否readonly，以及特定异常是否回滚等，但使用较为繁琐，大多时候并不需要如此细粒度控制。</p>
<p><strong>基于Annotation使用起来更方便,添加&#64;Transactional即可</strong>。</p>
<p>详情可参考：Spring 声明式事务管理：https://blog.csdn.net/q343509740/article/details/80765327</p>
<p>声明式事务实现上又可分为xml方式和Annotation方式</p>
<p>xml方式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   &lt;!-- 事务管理器，依赖于数据源 --&gt;
    &lt;bean id=&quot;txManager&quot;
        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;
    &lt;!-- 编写通知：对事务进行增强（通知），需要编写切入点和具体执行事务的细节 --&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，propagation用于设置传播行为，read-only表示隔离级别，是否只读 --&gt;
            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot;
                rollback-for=&quot;Exception&quot; /&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot;
                read-only=&quot;false&quot; /&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    &lt;!-- aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 切入点 --&gt;
        &lt;aop:pointcut expression=&quot;execution(* com.mengma.service.*.*(..))&quot;
            id=&quot;txPointCut&quot; /&gt;
        &lt;!-- 切面：将切入点与通知整合 --&gt;
        &lt;aop:advisor pointcut-ref=&quot;txPointCut&quot; advice-ref=&quot;txAdvice&quot; /&gt;
    &lt;/aop:config&gt;
</pre></div>
</div>
<p>Annotation方式</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@Transactional</span><span class="p">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">isolation</span> <span class="o">=</span> <span class="n">Isolation</span><span class="o">.</span><span class="n">DEFAULT</span><span class="p">,</span> <span class="n">readOnly</span> <span class="o">=</span> <span class="n">false</span><span class="p">)</span>
<span class="n">public</span> <span class="k">class</span> <span class="nc">AccountServiceImpl</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">AccountDao</span> <span class="n">accountDao</span><span class="p">;</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">setAccountDao</span><span class="p">(</span><span class="n">AccountDao</span> <span class="n">accountDao</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">accountDao</span> <span class="o">=</span> <span class="n">accountDao</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">transfer</span><span class="p">(</span><span class="n">String</span> <span class="n">outUser</span><span class="p">,</span> <span class="n">String</span> <span class="n">inUser</span><span class="p">,</span> <span class="nb">int</span> <span class="n">money</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">accountDao</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="n">outUser</span><span class="p">,</span> <span class="n">money</span><span class="p">);</span>
        <span class="o">//</span> <span class="n">模拟断电</span>
        <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">this</span><span class="o">.</span><span class="n">accountDao</span><span class="o">.</span><span class="ow">in</span><span class="p">(</span><span class="n">inUser</span><span class="p">,</span> <span class="n">money</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当然，即使是Annotation方式，也需要在xml中注册事务相关组件的</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;!-- 事务管理器，依赖于数据源 --&gt;
&lt;bean id=&quot;txManager&quot;
    class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
&lt;!-- 注册事务管理驱动 --&gt;
&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;
</pre></div>
</div>
</div>
</div>
<div class="section" id="id21">
<h2>参考<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<p>Spring IoC容器：BeanFactory和ApplicationContext:http://c.biancheng.net/view/4248.html</p>
<p>Spring 教程：https://www.w3cschool.cn/wkspring/</p>
<p>Spring IoC有什么好处：实例，https://blog.csdn.net/xuefeiliuyuxiu/article/details/79181540</p>
<p>Spring注入值得2种方式：属性注入和构造注入：https://www.cnblogs.com/LiuChunfu/p/5574546.html</p>
<p>spring事务详解（一）初探事务【table】：https://www.cnblogs.com/dennyzhangdd/p/9549535.html</p>
<p>【概念题】java依赖注入（DI）与自动装配（Autowired）之间的关系(依赖注入的本质就是装配，装配是依赖注入的具体行为)：https://blog.csdn.net/qq15577969/article/details/104312023</p>
<p>强大的【环绕通知】:https://blog.csdn.net/weixin_33758863/article/details/94070334</p>
<p>13–Spring 构造函数注入和Setter方法注入及集合注入（一）:https://blog.csdn.net/lyc_liyanchao/article/details/82428726</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="java_spring02ioc有什么优点.html" class="btn btn-neutral float-right" title="java_spring02ioc有什么优点" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="java_并发编程11线程池.html" class="btn btn-neutral float-left" title="java_并发编程11线程池" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, yuanjh

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>