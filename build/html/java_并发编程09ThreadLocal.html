

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>java_并发编程09ThreadLocal &mdash; java基础 v1.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="java_并发编程10阻塞队列" href="java_并发编程10阻塞队列.html" />
    <link rel="prev" title="java_并发编程08CyclicBarrier_CountDownLatch_Semaphore" href="java_并发编程08CyclicBarrier_CountDownLatch_Semaphore.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> java基础
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="java_读书01guide学习笔记.html">java_读书01guide学习笔记</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书02java核心面试知识整理.html">java_读书02java核心面试知识整理</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书03Java基础高频面试题(2021年最新版).html">java_读书03Java基础高频面试题(2021年最新版)</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书05殷建卫架构笔记之java.html">java_读书05殷建卫架构笔记之java</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础01常见坑.html">java_基础01常见坑</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础02集合.html">java_基础02集合</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础03双亲委派.html">java_基础03双亲委派</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础04内存结构和gc垃圾回收.html">java_基础04内存结构和gc垃圾回收</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程01JMM内存模型.html">java_并发编程01JMM内存模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程02Volatile.html">java_并发编程02Volatile</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程03Atomic原子类和CAS.html">java_并发编程03Atomic原子类和CAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程04Synchronized.html">java_并发编程04Synchronized</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程05从锁到ReentrantLock.html">java_并发编程05从锁到ReentrantLock</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程06从ReentrantLock到AQS.html">java_并发编程06从ReentrantLock到AQS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程07锁相关小结.html">java_并发编程07锁相关小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程08CyclicBarrier_CountDownLatch_Semaphore.html">java_并发编程08CyclicBarrier_CountDownLatch_Semaphore</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">java_并发编程09ThreadLocal</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#threadlocal">ThreadLocal简单使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">ThreadLocal常用方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">ThreadLocal实现原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="#threadloalmap">ThreadLoalMap</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hash">hash冲突</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">内存泄露</a></li>
<li class="toctree-l3"><a class="reference internal" href="#threadlocalmapkey">为什么ThreadLocalMap的key要设计成弱引用</a></li>
<li class="toctree-l3"><a class="reference internal" href="#map">为啥需要使用 Map 呢？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">如何避免内存泄露</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">何时使用ThreadLocal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">数据库连接</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">传参</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simpledateformat">SimpleDateFormat 的并发安全问题</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id8">ThreadLocal不支持继承性</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inheritablethreadlocal">InheritableThreadLocal类</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">参考</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程10阻塞队列.html">java_并发编程10阻塞队列</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程11线程池.html">java_并发编程11线程池</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring01读书要点.html">java_spring01读书要点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring02ioc有什么优点.html">java_spring02ioc有什么优点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring03依赖注入与自动装配区别.html">java_spring03依赖注入与自动装配区别</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring04Autowired与Resource差异解析.html">java_spring04Autowired与Resource差异解析</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring05循环依赖.html">java_spring05循环依赖</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_mybatis学习要点.html">java_mybatis学习要点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_微服务01学习笔记.html">java_微服务01学习笔记</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">java基础</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>java_并发编程09ThreadLocal</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/java_并发编程09ThreadLocal.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="java-09threadlocal">
<h1>java_并发编程09ThreadLocal<a class="headerlink" href="#java-09threadlocal" title="Permalink to this headline">¶</a></h1>
<p>ThreadLocal提高一个线程的局部变量，访问某个线程拥有自己局部变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题。</p>
<div class="section" id="threadlocal">
<h2>ThreadLocal简单使用<a class="headerlink" href="#threadlocal" title="Permalink to this headline">¶</a></h2>
<p>下面的例子中，开启两个线程，在每个线程内部设置了本地变量的值，然后调用print方法打印当前本地变量的值。如果在打印之后调用本地变量的remove方法会删除本地内存中的变量，代码如下所示</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">1</span> <span class="n">package</span> <span class="n">test</span><span class="p">;</span>
 <span class="mi">2</span> 
 <span class="mi">3</span> <span class="n">public</span> <span class="k">class</span> <span class="nc">ThreadLocalTest</span> <span class="p">{</span>
 <span class="mi">4</span> 
 <span class="mi">5</span>     <span class="n">static</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">localVar</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ThreadLocal</span><span class="o">&lt;&gt;</span><span class="p">();</span>
 <span class="mi">6</span> 
 <span class="mi">7</span>     <span class="n">static</span> <span class="n">void</span> <span class="nb">print</span><span class="p">(</span><span class="n">String</span> <span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">8</span>         <span class="o">//</span><span class="n">打印当前线程中本地内存中本地变量的值</span>
 <span class="mi">9</span>         <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="nb">str</span> <span class="o">+</span> <span class="s2">&quot; :&quot;</span> <span class="o">+</span> <span class="n">localVar</span><span class="o">.</span><span class="n">get</span><span class="p">());</span>
<span class="mi">10</span>         <span class="o">//</span><span class="n">清除本地内存中的本地变量</span>
<span class="mi">11</span>         <span class="n">localVar</span><span class="o">.</span><span class="n">remove</span><span class="p">();</span>
<span class="mi">12</span>     <span class="p">}</span>
<span class="mi">13</span> 
<span class="mi">14</span>     <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">15</span>         <span class="n">Thread</span> <span class="n">t1</span>  <span class="o">=</span> <span class="n">new</span> <span class="n">Thread</span><span class="p">(</span><span class="n">new</span> <span class="n">Runnable</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">16</span>             <span class="nd">@Override</span>
<span class="mi">17</span>             <span class="n">public</span> <span class="n">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">18</span>                 <span class="o">//</span><span class="n">设置线程1中本地变量的值</span>
<span class="mi">19</span>                 <span class="n">localVar</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;localVar1&quot;</span><span class="p">);</span>
<span class="mi">20</span>                 <span class="o">//</span><span class="n">调用打印方法</span>
<span class="mi">21</span>                 <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;thread1&quot;</span><span class="p">);</span>
<span class="mi">22</span>                 <span class="o">//</span><span class="n">打印本地变量</span>
<span class="mi">23</span>                 <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;after remove : &quot;</span> <span class="o">+</span> <span class="n">localVar</span><span class="o">.</span><span class="n">get</span><span class="p">());</span>
<span class="mi">24</span>             <span class="p">}</span>
<span class="mi">25</span>         <span class="p">});</span>
<span class="mi">26</span> 
<span class="mi">27</span>         <span class="n">Thread</span> <span class="n">t2</span>  <span class="o">=</span> <span class="n">new</span> <span class="n">Thread</span><span class="p">(</span><span class="n">new</span> <span class="n">Runnable</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">28</span>             <span class="nd">@Override</span>
<span class="mi">29</span>             <span class="n">public</span> <span class="n">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
<span class="mi">30</span>                 <span class="o">//</span><span class="n">设置线程1中本地变量的值</span>
<span class="mi">31</span>                 <span class="n">localVar</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;localVar2&quot;</span><span class="p">);</span>
<span class="mi">32</span>                 <span class="o">//</span><span class="n">调用打印方法</span>
<span class="mi">33</span>                 <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;thread2&quot;</span><span class="p">);</span>
<span class="mi">34</span>                 <span class="o">//</span><span class="n">打印本地变量</span>
<span class="mi">35</span>                 <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;after remove : &quot;</span> <span class="o">+</span> <span class="n">localVar</span><span class="o">.</span><span class="n">get</span><span class="p">());</span>
<span class="mi">36</span>             <span class="p">}</span>
<span class="mi">37</span>         <span class="p">});</span>
<span class="mi">38</span> 
<span class="mi">39</span>         <span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">();</span>
<span class="mi">40</span>         <span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">();</span>
<span class="mi">41</span>     <span class="p">}</span>
<span class="mi">42</span> <span class="p">}</span>
</pre></div>
</div>
<p>下面是运行后的结果：</p>
<p><img alt="_images/20210410232257632_1783892740.png" src="_images/20210410232257632_1783892740.png" /></p>
</div>
<div class="section" id="id1">
<h2>ThreadLocal常用方法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p><img alt="_images/20210410213728598_1451858355.png" src="_images/20210410213728598_1451858355.png" /></p>
<p>get()方法：获取与当前线程关联的ThreadLocal值。</p>
<p>set(T value)方法：设置与当前线程关联的ThreadLocal值。</p>
<p>initialValue()方法：设置与当前线程关联的ThreadLocal初始值。</p>
<p>当调用get()方法的时候，若是与当前线程关联的ThreadLocal值已经被设置过，则不会调用initialValue()方法；否则，会调用initialValue()方法来进行初始值的设置。通常initialValue()方法只会被调用一次，除非调用了remove()方法之后又调用get()方法，此时，与当前线程关联的ThreadLocal值处于没有设置过的状态（其状态体现在源码中，就是线程的ThreadLocalMap对象是否为null），initialValue()方法仍会被调用。</p>
<p>initialValue()方法是protected类型的，很显然是建议在子类重载该函数的，所以通常该方法都会以匿名内部类的形式被重载，以指定初始值，例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">ThreadLocalTest</span> <span class="p">{</span>
	<span class="n">public</span> <span class="n">static</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">threadLocal</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
		<span class="nd">@Override</span>
		<span class="n">protected</span> <span class="n">Integer</span> <span class="n">initialValue</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="n">valueOf</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>remove()方法：将与当前线程关联的ThreadLocal值删除。</p>
</div>
<div class="section" id="id2">
<h2>ThreadLocal实现原理<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>ThreadLocal实现原理</p>
<p><img alt="_images/20210410221635023_2094722186.png" src="_images/20210410221635023_2094722186.png" /></p>
<p>ThreadLocal实现原理
每个线程对象里会持有一个java.lang.ThreadLocal.<strong>ThreadLocalMap类型的threadLocals成员变量(特别注意threadLocals看做threadLocalMap可能更合适，习惯用类小写标识对应实例)</strong>，而ThreadLocalMap里有一个java.lang.ThreadLocal.ThreadLocalMap.Entry[]类型的table成员，这是一个<strong>数组，数组元素是Entry类型，Entry中相当于有一个key和value，key指向所有线程共享的java.lang.ThreadLocal对象，value指向各线程私有的变量，这样保证了线程局部变量的隔离性</strong>，每个线程只是读取和修改自己所持有的那个value对象，相互之间没有影响。</p>
<p>ThreadLocal最简单的实现方式就是ThreadLocal类内部有一个线程安全的Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。</p>
<p>JDK最早期的ThreadLocal就是这样设计的，但是，之后ThreadLocal的设计换了一种方式，我们先看get()方法的源码，然后进一步介绍ThreadLocal的实现方式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">T</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="n">currentThread</span><span class="p">();</span>
    <span class="n">ThreadLocalMap</span> <span class="nb">map</span> <span class="o">=</span> <span class="n">getMap</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">map</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ThreadLocalMap</span><span class="o">.</span><span class="n">Entry</span> <span class="n">e</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">getEntry</span><span class="p">(</span><span class="n">this</span><span class="p">);</span><span class="c1">#这里是this,而非t</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s2">&quot;unchecked&quot;</span><span class="p">)</span>
            <span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">e</span><span class="o">.</span><span class="n">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">setInitialValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>get()方法主要做了以下事情：</p>
<p>1、调用Thread.currentThread()获取当前线程对象t；</p>
<p>2、根据当前线程对象，调用getMap(Thread)获取线程对应的ThreadLocalMap对象：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ThreadLocalMap</span> <span class="n">getMap</span><span class="p">(</span><span class="n">Thread</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">threadLocals</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>threadLocals是Thread类的成员变量，初始化为null：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">ThreadLocal</span> <span class="n">values</span> <span class="n">pertaining</span> <span class="n">to</span> <span class="n">this</span> <span class="n">thread</span><span class="o">.</span> <span class="n">This</span> <span class="nb">map</span> <span class="ow">is</span> <span class="n">maintained</span>
     <span class="o">*</span> <span class="n">by</span> <span class="n">the</span> <span class="n">ThreadLocal</span> <span class="n">class</span><span class="o">.</span> <span class="o">*/</span>
<span class="n">ThreadLocal</span><span class="o">.</span><span class="n">ThreadLocalMap</span> <span class="n">threadLocals</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</pre></div>
</div>
<p>所以每个 Thread 都会拥有一个 ThreadLocalMap 变量，来存放属于该 Thread 的所有 ThreadLocal 变量。这样来看的话，ThreadLocal就相当于一个调度器，每次调用 get 方法的时候，都会先找到当前线程的 ThreadLocalMap，然后再在这个 ThreadLocalMap 中找到对应的线程本地变量。</p>
<p><img alt="_images/20210410234244577_1480777171.png" src="_images/20210410234244577_1480777171.png" /></p>
<p>3、如果获取的map不为空，则在map中以ThreadLocal的引用作为key来在map中获取对应的value e，否则转到步骤5；</p>
<p>补充:<strong>获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是  this，而不是当前线程t</strong>。</p>
<p>4、若e不为null，则返回e中存储的value值，否则转到步骤5；</p>
<p>5、调用setInitialValue()方法，对线程的ThreadLocalMap对象进行初始化操作，ThreadLocalMap对象的key为ThreadLocal对象，value为initialValue()方法的返回值。</p>
<p>从上面的分析中，可以看到，ThreadLocal的实现离不开ThreadLocalMap类，ThreadLocalMap类是ThreadLocal的静态内部类。每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。这样的设计主要有以下几点优势：</p>
<p>01，这样设计之后每个Map的Entry数量变小了：之前是Thread的数量，现在是ThreadLocal的数量，能提高性能；</p>
<p>02，当Thread销毁之后对应的ThreadLocalMap也就随之销毁了，能减少内存使用量。</p>
</div>
<div class="section" id="threadloalmap">
<h2>ThreadLoalMap<a class="headerlink" href="#threadloalmap" title="Permalink to this headline">¶</a></h2>
<p>本文分析的是1.7的源码。</p>
<p>从名字上看，可以猜到它也是一个类似HashMap的数据结构，但是在ThreadLocal中，并没实现Map接口。</p>
<p>在ThreadLoalMap中，也是初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过<strong>这里的key永远都是ThreadLocal对象</strong>，是不是很神奇，<strong>通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key</strong>，放进了ThreadLoalMap中。
<img alt="_images/20210410231536369_1790378365.png" src="_images/20210410231536369_1790378365.png" /></p>
<p>这里需要注意的是，ThreadLoalMap的Entry是继承WeakReference，和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况了。</p>
<div class="section" id="hash">
<h3>hash冲突<a class="headerlink" href="#hash" title="Permalink to this headline">¶</a></h3>
<p>没有链表结构，那发生hash冲突了怎么办？</p>
<p>先看看ThreadLoalMap中插入一个key-value的实现</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>private void set(ThreadLocal&lt;?&gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len-1);

    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&lt;?&gt; k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        rehash();
}
</pre></div>
</div>
<p>每个ThreadLocal对象都有一个hash值threadLocalHashCode，每初始化一个ThreadLocal对象，hash值就增加一个固定的大小0x61c88647。</p>
<p>在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，过程如下：</p>
<p>1、如果当前位置是空的，那么正好，就初始化一个Entry对象放在位置i上；</p>
<p>2、不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value；</p>
<p>3、很不巧，位置i的Entry对象，和即将设置的key没关系，那么只能找下一个空位置；</p>
<p>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置</p>
<p>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLoalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其它代码的行为。</p>
</div>
<div class="section" id="id3">
<h3>内存泄露<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>ThreadLocal在保存的时候会把自己当做Key存在ThreadLocalMap中，正常情况应该是key和value都应该被外界强引用才对，但是现在key被设计成WeakReference弱引用了</p>
<p><img alt="_images/20210410233118084_262364013.png" src="_images/20210410233118084_262364013.png" /></p>
<p>这就导致了一个问题，ThreadLocal在没有外部强引用时，发生GC时会被回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p>
<p>就比如线程池里面的线程，线程都是复用的，那么之前的线程实例处理完之后，出于复用的目的线程依然存活，所以，ThreadLocal设定的value值被持有，导致内存泄露。</p>
<p>按照道理一个线程使用完，ThreadLocalMap是应该要被清空的，但是现在线程被复用了。</p>
<p>那怎么解决？</p>
<p>在代码的最后使用remove就好了，我们只要记得在使用的最后用remove把值清空就好了。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ThreadLocal&lt;String&gt; localName = new ThreadLocal();
try {
    localName.set(&quot;张三&quot;);
    ……
} finally {
    localName.remove();
}
</pre></div>
</div>
<p>remove的源码很简单，找到对应的值全部置空，这样在垃圾回收器回收的时候，会自动把他们回收掉。</p>
</div>
<div class="section" id="threadlocalmapkey">
<h3>为什么ThreadLocalMap的key要设计成弱引用<a class="headerlink" href="#threadlocalmapkey" title="Permalink to this headline">¶</a></h3>
<p>设计成弱引用的目的是为了更好地对ThreadLocal进行回收，当我们在代码中将ThreadLocal的强引用置为null后，这时候Entry中的ThreadLocal理应被回收了，但是如果Entry的key被设置成强引用则该ThreadLocal就不能被回收，这就是将其设置成弱引用的目的。</p>
</div>
<div class="section" id="map">
<h3>为啥需要使用 Map 呢？<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h3>
<p>因为一个线程可能有多个 ThreadLocal 对象，可能是包含 SimpleDateFormat，也可能是包含一个数据库连接 Connection，所以不同的变量需要通过对应的 ThreadLocal 对象来快速查找 —— 那么 Map 当然是最好的方式。</p>
</div>
<div class="section" id="id4">
<h3>如何避免内存泄露<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>既然已经发现有内存泄露的隐患，自然有应对的策略，在调用ThreadLocal的get()、set()可能会清除ThreadLocalMap中key为null的Entry对象，这样对应的value就没有GC Roots可达了，下次GC的时候就可以被回收，当然如果调用remove方法，肯定会删除对应的Entry对象。</p>
<p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">localName</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ThreadLocal</span><span class="p">();</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="n">localName</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;占小狼&quot;</span><span class="p">);</span>
    <span class="o">//</span> <span class="n">其它业务逻辑</span>
<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="n">localName</span><span class="o">.</span><span class="n">remove</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h2>何时使用ThreadLocal<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id6">
<h3>数据库连接<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。</p>
<p>如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">connectionHolder</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">public</span> <span class="n">Connection</span> <span class="n">initialValue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">DriverManager</span><span class="o">.</span><span class="n">getConnection</span><span class="p">(</span><span class="n">DB_URL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
 
<span class="n">public</span> <span class="n">static</span> <span class="n">Connection</span> <span class="n">getConnection</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">connectionHolder</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>传参<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>用来提供线程内部的共享变量，在多线程环境下，可以保证各个线程之间的变量互相隔离、相互独立。在线程中，可以通过get()/set()方法来访问变量。ThreadLocal实例通常来说都是private static类型的，它们希望将状态与线程进行关联。这种变量在线程的生命周期内起作用，可以减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p>
</div>
<div class="section" id="simpledateformat">
<h3>SimpleDateFormat 的并发安全问题<a class="headerlink" href="#simpledateformat" title="Permalink to this headline">¶</a></h3>
<p>很多人为了提高性能，会把 private static final SimpleDateFormat simpleDateFormat=new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); 作为全局变量来写代码；这样写代码会有并发问题，因为 在调用format 或者parse等方法的时候，该类的对象会用到全局变量，一旦涉及到全局变量问题，那么同一个类的对象去面对并发多线程问题，会互相影响彼此的操作数据，导致可能出现异常情况。</p>
<p>在SimpleDateFormat转换日期是通过Calendar对象来操作的，SimpleDateFormat继承DateFormat类，DateFormat类中维护一个Calendar对象，代码如下：</p>
<p><img alt="_images/20210410212123699_412787895.png" src="_images/20210410212123699_412787895.png" /></p>
<p>可知SimpleDateFormat维护的用于format和parse方法计算日期-时间的calendar被清空了，如果此时线程A将calendar清空且没有设置新值，线程B也进入parse方法用到了SimpleDateFormat对象中的calendar对象，此时就会产生线程安全问题！</p>
<p><strong>解决SimpleDateFormat 的并发问题</strong></p>
<p>一：当前比较受欢迎的方法，利用空间换时间，放在threadLocal中，保证了线程的安全，借助threadlocal对象每个线程只创建一个实例</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">ConcurrentDateFormat</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">static</span> <span class="n">final</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">SimpleDateFormat</span><span class="o">&gt;</span>  <span class="n">_threadLocal</span><span class="o">=</span><span class="n">new</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">SimpleDateFormat</span><span class="o">&gt;</span><span class="p">(){</span>

    <span class="nd">@Override</span>
    <span class="n">protected</span> <span class="n">SimpleDateFormat</span> <span class="n">initialValue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">new</span> <span class="n">SimpleDateFormat</span><span class="p">(</span><span class="n">yyyy_mmdd_hhmm</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
    <span class="o">/**</span>
     <span class="o">*</span> <span class="n">格式化时间</span>
     <span class="o">*/</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">String</span> <span class="n">formatDateTime</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">_threadLocal</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">date</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>二：加锁，简单粗暴</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">tests</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">static</span> <span class="n">final</span> <span class="n">SimpleDateFormat</span> <span class="nb">format</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SimpleDateFormat</span><span class="p">(</span><span class="s2">&quot;yyyy-MM-dd hh:mm:ss&quot;</span><span class="p">);</span>
    <span class="n">public</span> <span class="n">synchronized</span> <span class="n">static</span> <span class="n">String</span> <span class="n">DateToStringFormat</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">date</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>二：jdk8之后的time包，jdk8之后引入了，java.time.XXX相关的包，是线程安全的类。Date 和 LocalDateTime相互转化相关，</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">tests</span> <span class="p">{</span>
    <span class="o">//</span>    <span class="n">private</span> <span class="n">static</span> <span class="n">final</span> <span class="n">SimpleDateFormat</span> <span class="nb">format</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SimpleDateFormat</span><span class="p">(</span><span class="s2">&quot;yyyy-MM-dd hh:mm:ss&quot;</span><span class="p">);</span>
    <span class="n">private</span> <span class="n">static</span> <span class="n">final</span> <span class="n">DateTimeFormatter</span> <span class="n">_format</span> <span class="o">=</span> <span class="n">DateTimeFormatter</span><span class="o">.</span><span class="n">ofPattern</span><span class="p">(</span><span class="s2">&quot;yyyy-MM-dd hh:mm:ss&quot;</span><span class="p">);</span>

    <span class="n">public</span> <span class="n">synchronized</span> <span class="n">static</span> <span class="n">String</span> <span class="n">DateToStringFormat</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LocalDateTime</span> <span class="n">time</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="n">ofInstant</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">toInstant</span><span class="p">(),</span> <span class="n">ZoneId</span><span class="o">.</span><span class="n">systemDefault</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h2>ThreadLocal不支持继承性<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>同一个ThreadLocal变量在父线程中被设置值后，在子线程中是获取不到的。（threadLocals中为当前调用线程对应的本地变量，所以二者自然是不能共享的）</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">test</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">ThreadLocalTest2</span> <span class="p">{</span>

    <span class="o">//</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="n">创建ThreadLocal变量</span>
    <span class="n">public</span> <span class="n">static</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">threadLocal</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ThreadLocal</span><span class="o">&lt;&gt;</span><span class="p">();</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">//</span><span class="n">在main线程中添加main线程的本地变量</span>
        <span class="n">threadLocal</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;mainVal&quot;</span><span class="p">);</span>
        <span class="o">//</span><span class="n">新创建一个子线程</span>
        <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Thread</span><span class="p">(</span><span class="n">new</span> <span class="n">Runnable</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">@Override</span>
            <span class="n">public</span> <span class="n">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;子线程中的本地变量值:&quot;</span><span class="o">+</span><span class="n">threadLocal</span><span class="o">.</span><span class="n">get</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">();</span>
        <span class="o">//</span><span class="n">输出main线程中的本地变量值</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;mainx线程中的本地变量值:&quot;</span><span class="o">+</span><span class="n">threadLocal</span><span class="o">.</span><span class="n">get</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="inheritablethreadlocal">
<h2>InheritableThreadLocal类<a class="headerlink" href="#inheritablethreadlocal" title="Permalink to this headline">¶</a></h2>
<p>在上面说到的ThreadLocal类是不能提供子线程访问父线程的本地变量的，而InheritableThreadLocal类则可以做到这个功能，下面是该类的源码</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">1</span> <span class="n">public</span> <span class="k">class</span> <span class="nc">InheritableThreadLocal</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">extends</span> <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="mi">2</span>     
 <span class="mi">3</span>     <span class="n">protected</span> <span class="n">T</span> <span class="n">childValue</span><span class="p">(</span><span class="n">T</span> <span class="n">parentValue</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">4</span>         <span class="k">return</span> <span class="n">parentValue</span><span class="p">;</span>
 <span class="mi">5</span>     <span class="p">}</span>
 <span class="mi">6</span> 
 <span class="mi">7</span>     <span class="n">ThreadLocalMap</span> <span class="n">getMap</span><span class="p">(</span><span class="n">Thread</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">8</span>        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">inheritableThreadLocals</span><span class="p">;</span>
 <span class="mi">9</span>     <span class="p">}</span>
<span class="mi">10</span> 
<span class="mi">11</span>     <span class="n">void</span> <span class="n">createMap</span><span class="p">(</span><span class="n">Thread</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span> <span class="n">firstValue</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">12</span>         <span class="n">t</span><span class="o">.</span><span class="n">inheritableThreadLocals</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ThreadLocalMap</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">firstValue</span><span class="p">);</span>
<span class="mi">13</span>     <span class="p">}</span>
<span class="mi">14</span> <span class="p">}</span>
</pre></div>
</div>
<p>从上面代码可以看出，InheritableThreadLocal类继承了ThreadLocal类，并重写了childValue、getMap、createMap三个方法。其中createMap方法在被调用（当前线程调用set方法时得到的map为null的时候需要调用该方法）的时候，创建的是inheritableThreadLocal而不是threadLocals。同理，getMap方法在当前调用者线程调用get方法的时候返回的也不是threadLocals而是inheritableThreadLocal。</p>
<p>总之，InheritableThreadLocals类<strong>通过重写getMap和createMap两个方法将本地变量保存到了具体线程的inheritableThreadLocals变量中</strong>，当线程通过InheritableThreadLocals实例的set或者get方法设置变量的时候，就会创建当前线程的inheritableThreadLocals变量。而<strong>父线程创建子线程的时候，ThreadLocalMap中的构造函数会将父线程的inheritableThreadLocals中的变量复制一份到子线程的inheritableThreadLocals变量中</strong>。</p>
</div>
<div class="section" id="id9">
<h2>参考<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>Java中的ThreadLocal详解：https://www.cnblogs.com/fsmly/p/11020641.html</p>
<p>java SimpleDateFormat并发问题：https://blog.csdn.net/m0_37664223/article/details/96571737</p>
<p>Java并发编程之ThreadLocal详解:https://blog.csdn.net/qq_38293564/article/details/80459827</p>
<p>Java ThreadLocal用法实例详解;https://www.jb51.net/article/170439.htm</p>
<p>Java面试必问，ThreadLocal终极篇:https://www.jianshu.com/p/377bb840802f</p>
<p>Java中的ThreadLocal详解:https://www.cnblogs.com/fsmly/p/11020641.html</p>
<p>Java中ThreadLocal的实际用途是啥？:https://www.zhihu.com/question/341005993</p>
<p>Java 多线程（7）： ThreadLocal 的应用及原理:https://segmentfault.com/a/1190000010251063</p>
<p>Java并发编程：深入剖析ThreadLocal:https://www.cnblogs.com/dolphin0520/p/3920407.html</p>
<p>ThreadLocalMap的enrty的key为什么要设置成弱引用:https://blog.csdn.net/qq646040754/article/details/82493409</p>
<p>ThreadLocal底层原理学习:https://www.cnblogs.com/bangiao/p/13204983.html</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="java_并发编程10阻塞队列.html" class="btn btn-neutral float-right" title="java_并发编程10阻塞队列" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="java_并发编程08CyclicBarrier_CountDownLatch_Semaphore.html" class="btn btn-neutral float-left" title="java_并发编程08CyclicBarrier_CountDownLatch_Semaphore" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, yuanjh

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>