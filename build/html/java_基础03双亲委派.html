

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>java_基础03双亲委派 &mdash; java基础 v1.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="java_基础04内存结构和gc垃圾回收" href="java_基础04内存结构和gc垃圾回收.html" />
    <link rel="prev" title="java_基础02集合" href="java_基础02集合.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> java基础
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="java_读书01guide学习笔记.html">java_读书01guide学习笔记</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书02java核心面试知识整理.html">java_读书02java核心面试知识整理</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书03Java基础高频面试题(2021年最新版).html">java_读书03Java基础高频面试题(2021年最新版)</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_读书05殷建卫架构笔记之java.html">java_读书05殷建卫架构笔记之java</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础01常见坑.html">java_基础01常见坑</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_基础02集合.html">java_基础02集合</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">java_基础03双亲委派</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">类加载器</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">源码分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">双亲委派机制的作用</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">打破双亲委派</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">其他</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">类加载器工作流程和加载细节</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-forname-classloader-loadclass">Class.forName()和ClassLoader.loadClass()的区别</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">参考</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="java_基础04内存结构和gc垃圾回收.html">java_基础04内存结构和gc垃圾回收</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程01JMM内存模型.html">java_并发编程01JMM内存模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程02Volatile.html">java_并发编程02Volatile</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程03Atomic原子类和CAS.html">java_并发编程03Atomic原子类和CAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程04Synchronized.html">java_并发编程04Synchronized</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程05从锁到ReentrantLock.html">java_并发编程05从锁到ReentrantLock</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程06从ReentrantLock到AQS.html">java_并发编程06从ReentrantLock到AQS</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程07锁相关小结.html">java_并发编程07锁相关小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程08CyclicBarrier_CountDownLatch_Semaphore.html">java_并发编程08CyclicBarrier_CountDownLatch_Semaphore</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程09ThreadLocal.html">java_并发编程09ThreadLocal</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程10阻塞队列.html">java_并发编程10阻塞队列</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_并发编程11线程池.html">java_并发编程11线程池</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring01读书要点.html">java_spring01读书要点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring02ioc有什么优点.html">java_spring02ioc有什么优点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring03依赖注入与自动装配区别.html">java_spring03依赖注入与自动装配区别</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring04Autowired与Resource差异解析.html">java_spring04Autowired与Resource差异解析</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_spring05循环依赖.html">java_spring05循环依赖</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_mybatis学习要点.html">java_mybatis学习要点</a></li>
<li class="toctree-l1"><a class="reference internal" href="java_微服务01学习笔记.html">java_微服务01学习笔记</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">java基础</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>java_基础03双亲委派</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/java_基础03双亲委派.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="java-03">
<h1>java_基础03双亲委派<a class="headerlink" href="#java-03" title="Permalink to this headline">¶</a></h1>
<p>双亲委派（可以理解为父类委派，parents翻译问题，理解起来有些费解）:当某个类加载器需要加载某个.class文件时，它首先<strong>把这个任务委托给他的上级类加载器，递归这个操作</strong>，如果上级的类加载器没有加载，自己才会去加载这个类。</p>
<div class="section" id="id1">
<h2>类加载器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>有四种加载器：</p>
<p>最基础：Bootstrap ClassLoader（加载JDK的/lib目录下的类）</p>
<p>次基础：Extension ClassLoader（加载JDK的/lib/ext目录下的类）</p>
<p>普通：Application ClassLoader（程序自己classpath下的类）</p>
<p>自定义：CustomClassLoader（用户自定义类加载器）</p>
<p>其关系如下:</p>
<p><img alt="_images/20210401201406614_714722460.png" src="_images/20210401201406614_714722460.png" /></p>
</div>
<div class="section" id="id2">
<h2>源码分析<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>protected Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException{
    synchronized (getClassLoadingLock(name)) {
        // 首先检查这个classsh是否已经加载过了
        Class&lt;?&gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                // c==null表示没有加载，如果有父类的加载器则让父类加载器加载
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    //如果父类的加载器为空 则说明递归到bootStrapClassloader了
                    //bootStrapClassloader比较特殊无法通过get获取
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {}
            if (c == null) {
                //如果bootstrapClassLoader 仍然没有加载过，则递归回来，尝试自己去加载class
                long t1 = System.nanoTime();
                c = findClass(name);
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
</pre></div>
</div>
<p>流程图</p>
<p><img alt="_images/20210401202635818_1623272408.png" src="_images/20210401202635818_1623272408.png" /></p>
</div>
<div class="section" id="id3">
<h2>双亲委派机制的作用<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p><strong>提高效率</strong>：防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。</p>
<p><strong>保证安全性</strong>：保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。</p>
</div>
<div class="section" id="id4">
<h2>打破双亲委派<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢？</p>
<p>这并非是不可能的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载(在JDK1.3时放进rt.jar)，但JNDI的目的就是<strong>对资源进行集中管理和查找</strong>，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码，<strong>但启动类加载器不可能“认识”这些代码</strong>，该怎么办？</p>
<p>为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：<strong>线程上下文件类加载器</strong>(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，<strong>如果创建线程时还未设置，它将会从父线程中继承一个</strong>；如果在应用程序的全局范围内都没有设置过，那么这个类加载器<strong>默认就是应用程序类加载器</strong>。有了线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。</p>
<p>还有些是由于<strong>用户对程序的动态性的追求</strong>导致的，例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。</p>
</div>
<div class="section" id="id5">
<h2>其他<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id6">
<h3>类加载器工作流程和加载细节<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>类加载器工作流程和加载细节步骤以及和java的GC,内存的关系</p>
<p><img alt="_images/20210401201314642_1271481850.png" src="_images/20210401201314642_1271481850.png" /></p>
</div>
<div class="section" id="class-forname-classloader-loadclass">
<h3>Class.forName()和ClassLoader.loadClass()的区别<a class="headerlink" href="#class-forname-classloader-loadclass" title="Permalink to this headline">¶</a></h3>
<p>Class.forName(className)</p>
<p>内部实际调用的方法是? Class.forName(className,true,classloader);第2个boolean参数表示类是否需要初始化，?<strong>Class.forName(className)默认是需要初始化</strong>。一旦初始化，就会<strong>触发目标对象的 static块代码执行，static参数也也会被再次初始化</strong>。</p>
<p>ClassLoader.loadClass(className)</p>
<p>内部实际调用的方法是? ClassLoader.loadClass(className,false);第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接，由上面介绍可以，不进行链接意味着<strong>不进行包括初始化等一些列步骤</strong>，那么<strong>静态块和静态对象就不会得到执行</strong></p>
</div>
</div>
<div class="section" id="id7">
<h2>参考<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Java 中的双亲委派的“双”怎么理解 ？：https://www.zhihu.com/question/288949359?sort=created</p>
<p>阿里面试：什么地方违反了双亲委派模型：https://www.sohu.com/a/334000357_505800</p>
<p>JVM成神之路-类加载机制-双亲委派，破坏双亲委派：https://blog.csdn.net/w372426096/article/details/81901482</p>
<p>通俗易懂的双亲委派机制：https://blog.csdn.net/codeyanbao/article/details/82875064</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="java_基础04内存结构和gc垃圾回收.html" class="btn btn-neutral float-right" title="java_基础04内存结构和gc垃圾回收" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="java_基础02集合.html" class="btn btn-neutral float-left" title="java_基础02集合" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, yuanjh

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>